package org.ops4j.pax.repository.maven;import org.neo4j.graphdb.Direction;import org.neo4j.graphdb.GraphDatabaseService;import org.neo4j.graphdb.Node;import org.neo4j.graphdb.Path;import org.neo4j.graphdb.Relationship;import org.neo4j.graphdb.RelationshipType;import org.neo4j.graphdb.Transaction;import org.neo4j.graphdb.traversal.Evaluators;import org.neo4j.graphdb.traversal.TraversalDescription;import org.neo4j.kernel.EmbeddedGraphDatabase;import org.neo4j.kernel.Traversal;/** * */public class Neo4JBackedIndex<T, Q> implements Resolution<T, Q>{    final private GraphDatabaseService m_db;    public Neo4JBackedIndex( GraphDatabaseService db )    {        m_db = db;    }    public T put( T object, Q... parts )    {        // store parts as nodes (if not available) and add the *object* at the very end (if not existent already).        Transaction tx = m_db.beginTx();        try        {            Node node = m_db.getReferenceNode();            // node.setProperty( "id", "REF" );            for( Q part : parts )            {                node = checkAndAddPart( part, node );            }            Relationship singleRelationship = node.getSingleRelationship( MyRelationship.OBJECT, Direction.OUTGOING );            if( singleRelationship != null )            {                singleRelationship.getEndNode();                System.out.println( "Already exists " + object );                return (T) singleRelationship.getEndNode().getProperty( "id" );            }            else            {                Node finalNode = m_db.createNode();                finalNode.setProperty( "id", object );                System.out.println( "Create end point for " + object );                node.createRelationshipTo( finalNode, MyRelationship.OBJECT );            }            tx.success();        } finally        {            tx.finish();        }        return null;    }    private Node checkAndAddPart( Q part, Node node )    {        for( Relationship r : node.getRelationships( MyRelationship.PART, Direction.OUTGOING ) )        {            if( r.getEndNode().getProperty( "id" ).equals( part ) )            {                return r.getEndNode();            }        }        Node newNode = m_db.createNode();        newNode.setProperty( "id", part );        System.out.println( "Create part point for " + part );        node.createRelationshipTo( newNode, MyRelationship.PART );        return newNode;    }    // TODO: find out how to cancel "early" wrong traversals    public T get( Q... parts )    {        Node start = m_db.getReferenceNode();        TraversalDescription d = Traversal.description();        for( Path p : d.traverse( start ) )        {            if( p.lastRelationship().equals( MyRelationship.OBJECT ) )            {                // found!            }            Q part = parts[ p.length() ];        }        // just traverse on the parts, once we've reached, find "nearest" object.        // note: parts MAY be null which means we need to HOP over that node.        return null;    }    public enum MyRelationship implements RelationshipType    {        PART, OBJECT    }}