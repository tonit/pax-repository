/* * Copyright (C) 2010 Toni Menzel * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.ops4j.pax.repository.neo4j;import org.neo4j.graphdb.Direction;import org.neo4j.graphdb.Expander;import org.neo4j.graphdb.GraphDatabaseService;import org.neo4j.graphdb.Node;import org.neo4j.graphdb.Path;import org.neo4j.graphdb.Relationship;import org.neo4j.graphdb.RelationshipType;import org.neo4j.graphdb.Transaction;import org.neo4j.graphdb.traversal.BranchOrderingPolicy;import org.neo4j.graphdb.traversal.BranchSelector;import org.neo4j.graphdb.traversal.Evaluation;import org.neo4j.graphdb.traversal.Evaluator;import org.neo4j.graphdb.traversal.Evaluators;import org.neo4j.graphdb.traversal.TraversalBranch;import org.neo4j.graphdb.traversal.TraversalDescription;import org.neo4j.kernel.EmbeddedGraphDatabase;import org.neo4j.kernel.Traversal;/** * */public class Neo4JBackedIndex<T, Q> implements Resolution<T, Q>{    final private GraphDatabaseService m_db;    public Neo4JBackedIndex( GraphDatabaseService db )    {        m_db = db;    }    public T put( T object, Q... parts )    {        // store parts as nodes (if not available) and add the *object* at the very end (if not existent already).        Transaction tx = m_db.beginTx();        try        {            Node node = m_db.getReferenceNode();            // node.setProperty( "id", "REF" );            for( Q part : parts )            {                node = checkAndAddPart( part, node );            }            Relationship singleRelationship = node.getSingleRelationship( MyRelationship.OBJECT, Direction.OUTGOING );            if( singleRelationship != null )            {                singleRelationship.getEndNode();                System.out.println( "Already exists " + object );                return (T) singleRelationship.getEndNode().getProperty( "id" );            }            else            {                Node finalNode = m_db.createNode();                finalNode.setProperty( "id", object );                System.out.println( "Create end point for " + object );                node.createRelationshipTo( finalNode, MyRelationship.OBJECT );            }            tx.success();        } finally        {            tx.finish();        }        return object;    }    private Node checkAndAddPart( Q part, Node node )    {        for( Relationship r : node.getRelationships( MyRelationship.PART, Direction.OUTGOING ) )        {            if( r.getEndNode().getProperty( "id" ).equals( part ) )            {                return r.getEndNode();            }        }        Node newNode = m_db.createNode();        newNode.setProperty( "id", part );        System.out.println( "Create part point for " + part );        node.createRelationshipTo( newNode, MyRelationship.PART );        return newNode;    }    public T get( final Q... parts )    {        Evaluator evaler = new Evaluator()        {            public Evaluation evaluate( Path path )            {                if( path.length() == 0 )                {                    return Evaluation.EXCLUDE_AND_CONTINUE;                }                else if( path.length() > parts.length )                {                    return Evaluation.INCLUDE_AND_CONTINUE;                }                Q part = parts[ path.length() - 1 ];                Object id = path.endNode().getProperty( "id", "" );                System.out.println( "Eval item=" + path.length() + " path=" + path + "with part =\"" + part + "\" and id=\"" + id + "\"" );                if( part.equals( "" ) || part.equals( id ) )                {                    return Evaluation.INCLUDE_AND_CONTINUE;                }                else                {                    return Evaluation.EXCLUDE_AND_PRUNE;                }            }        };        TraversalDescription d = Traversal.description().evaluator( evaler );        T highest = null;        Path best = null;        for( Path p : d.traverse( m_db.getReferenceNode() ) )        {            Relationship relationship = p.lastRelationship();            if( relationship != null && relationship.isType( MyRelationship.OBJECT ) )            {                if( ( push( best, p ) ) )                {                    best = p;                    // reset                    highest = (T) p.endNode().getProperty( "id" );                }            }            // select highest now:        }        return highest;    }    private boolean push( Path oldPath, Path newPath )    {        if( oldPath == null )        {            return true;        }        System.out.println( "Eval " + oldPath + " vs. " + newPath );        for( Node n : oldPath.nodes() )        {        }        return false;    }    public enum MyRelationship implements RelationshipType    {        PART, OBJECT    }}